{"meta":{"title":"ZeromaXHe的博客","subtitle":"欢迎来到ZeromaXHe的博客！","description":"测试一下用GitHub做博客是什么感觉，哈哈哈","author":"ZeromaXHe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Test","date":"2019-04-04T07:14:57.000Z","updated":"2019-04-04T07:17:29.752Z","comments":true,"path":"Test/index.html","permalink":"http://yoursite.com/Test/index.html","excerpt":"","text":"Try to test what the so-called Pages mean. (Still don’t know where they are…)"}],"posts":[{"title":"【笔记】《算法设计与分析（第三版）》王晓东著 第三章 动态规划","slug":"【笔记】《算法设计与分析（第三版）》-王晓东著-第三章-动态规划","date":"2019-04-06T11:52:53.000Z","updated":"2019-04-06T12:05:06.725Z","comments":true,"path":"2019/04/06/【笔记】《算法设计与分析（第三版）》-王晓东著-第三章-动态规划/","link":"","permalink":"http://yoursite.com/2019/04/06/【笔记】《算法设计与分析（第三版）》-王晓东著-第三章-动态规划/","excerpt":"","text":"第三章 动态规划动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法解这些问题，则分解得到的子问题数目太多，以至于最后解决原问题需要耗费指数时间。然而，不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。 为了达到这个目的，可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思想。具体的动态规划算法是多种多样的，但它们具有相同的填表样式。 动态规划算法适用于解最优化问题。通常可以按一下步骤设计动态规划算法： （1）找出最优解的性质，并刻画其结构特征； （2）递归地定义最优值； （3）以自底向上的方式计算出最优值； （4）根据计算最优值时得到的信息，构造最优解。 步骤（1）~（3）是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤（4）可以省去。若需要求问题的最优解，则必须执行步骤（4）。此时，在步骤（3）中计算最优值时，通常需记录更多的信息，以便在步骤（4）中，根据所记录的信息，快速构造出最优解。 3.1 矩阵连乘问题矩阵A和B可乘的条件是矩阵A的列数等于矩阵B的行数。若A是一个p*q矩阵，B是一个q*r矩阵，则其乘积C=AB是一个p*r矩阵。在上述计算C的标准算法中，主要计算量是3重循环，总共需要pqr次数乘。 矩阵连乘积的最优计算次序问题：对于给定的相继n个矩阵｛A1，A2，…，An｝（其中矩阵Ai的维数为p(i-1)*pi，i=1,2,…，n），如何确定计算矩阵连乘积A1A2…An的计算次序（完全加括号方式），使得依此次序计算矩阵连乘积需要的数乘次数最少。 穷举搜索法是最容易想到的方法。也就是列举出所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序。这样做计算量太大。事实上，对于n个矩阵的连乘积，设其不同的计算次序为P(n)。由于可以先在第k个和第k+1个矩阵之间将原矩阵序列分为2个矩阵子序列，k=1,2,…,n-1；然后分别对这2个矩阵子序列完全加括号；最后对所得的结果加括号，得到原矩阵序列的一种完全加括号方式。由此，可以得到关于P(n)的递推式如下：12P(n) = 1 n=1 (k=1~n-1)∑P(k)P(n-k) n&gt;1 解此递归方程可得，P(n)实际上是Catalan数，即P(n)=C(n-1),其中，C(n)=1/(n+1)\\*二项分布系数(2n n)=Ω(4^n/n^(3/2)) 也就是说，P(n)是随n的增长呈指数增长的。因此，穷举搜索法不是一个有效的算法。 下面考虑用动态规划法解矩阵连乘积的最优计算次序问题。 1.分析最优解的结构 这个问题的一个关键特征设：计算A[1:n]的最优次序所包含的计算矩阵子链A[1:k]和A[k+1:n]的次序也是最优的。事实上，若有一个计算A[1:k]的次序需要的计算量更少，则用此次序替换原来计算A[1:k]的次序，得到的计算A[1:n]的计算量将比按最优次序计算所需计算量更少，这是个矛盾。（反证法）同理可知子链A[k+1:n]也满足 因此，矩阵连乘积计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。 2.建立递归关系 设计动态规划算法的第二步是递归地定义最优值。对于矩阵连乘积的最优计算次序问题，设计算A[i:j],1&lt;=i&lt;=j&lt;=n,所需的最少数乘次数为m[i][j]，则原问题的最优值为m[1][n]。 当i=j时，可利用最优子结构性质计算m[i][j].事实上，若计算A[i:j]的最优次序在Ak和A（k+1）之间断开，i&lt;=k&lt;j,则m[i][j]+m[k+1][j]+p(i-1)*pk*pj。由于在计算时并不知道断开点k的位置，所以k还未定。不过k的位置只有j-i种可能，即k∈｛i,i+1，…，j-1｝。因此，k是这j-i个位置中使计算量达到最小的那个位置。 若将对应于m[i][j]的断开位置k记为s[i][j] ，在计算出最优值m[i][j]后，可递归地由s[i][j]构造出相应的最优解。 3. 计算最优值123456789101112131415161718public static void matrixChain(int []p, int [][]m, int [][]s)&#123; int n=p.length-1; for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int r=2;r&lt;=n;r++) for(int i=1;i&lt;=n-r+1;i++)&#123; int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[k]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j])&#123; m[i][j]=t; s[i][j]=k; &#125; &#125; &#125;&#125; 算法matrixChain的主要计算量取决于算法中对r,i和k的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3)。因此该算法的计算时间上界为O(n^3)。算法所占用的空间显然为O(n^2)。由此可见，动态规划法比穷举搜索法有效得多。 4. 构造最优解 动态规划算法的第四部是构造问题的最优解。算法matrixChain只是计算出了最优值，并未给出最优解。也就是说，通过算法matrixChain的计算，只知道最少乘次数，还不知道具体应按什么次序做矩阵乘法才能达到最少的数乘次数。 事实上，算法matrixChain已记录了构造最优解所需要的全部信息。 下面的算法traceback按算法matrixChain计算出的断点矩阵s指示的加括号方式输出计算A[i:j]的最优计算次序。1234567public static void traceback(int [][]s, int i, int j)&#123; if(i==j)return; traceback(s,i,s[i][j]); traceback(s,s[i][j]+1,j); System.out.println(\"Multiply A\"+i+\",\"+s[i][j]+\"and A\"+(s[i][j]+1)+\",\"+j);&#125; 3.2 动态规划算法的基本要素从计算矩阵连乘积最优计算次序的动态规划算法可以看出，该算法的有效性依赖于问题本身所具有的两个重要性质：最优子结构性质和子问题重叠性质。从一般的意义上讲，问题所具有的这两个重要性质是该问题可用动态规划算法求解的基本要素。 下面着重研究动态规划算法的这两个基本要素以及动态规划法的变形——备忘录方法。 1. 最优子结构 设计动态规划算法的第一步通常是刻画最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。 在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。算法考查的子问题空间规模较小。 2. 重叠子问题 可用动态规划算法求解的问题应该具备的另一个基本要素是子问题的重叠性质。也就是说，在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正式李永乐这种子问题的重叠性质，对每一个子问题都只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。 3. 备忘录方法 备忘录方法是动态规划算法的变形。与动态规划算法一样，备忘录方法用表格保存已解决的子问题的答案，在下次需要解此子问题时，只要简单地查看该子问题的解答，而不必重新计算。 与动态规划算法不同的是，备忘录方法的递归方式是自顶向下的，而动态规划算法是自底向上递归的。因此，备忘录方法的控制结构与直接递归方法的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。 备忘录方法为每个子问题建立一个记录项，初始化时，该记录项存入一个特殊值，表示该子问题尚未求解。在求解过程中，对每个待求子问题，首先查看其相应的记录项。若记录项中存储的是初始化时存入的特殊值，则表示该子问题是第一次遇到，此时计算出该子问题的解，并保存在其相应的记录项中，以备以后查看。若记录项中存储的已不是初始化时存入的特殊值，则表示该子问题已被计算过，其相应的记录项中存储的是该子问题的解答。此时，只要从记录项中取出该子问题的解答即可，而不必重新计算。 下面算法memorizedmatrixChain是解矩阵连乘积最优计算次序问题的备忘录方法： 12345678910111213141516171819202122public static int memorizedmatrixChain(int n)&#123; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j++) m[i][j]=0; return lookupChain(1,n);&#125;private static int lookupChain(int i, int j)&#123; if(m[i][j]&gt;0)return m[i][j]; if(i==j)return 0; int u=lookupChain(i+1,j)+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++)&#123; int t=lookupChain(i,k)+lookupChain(k+1,j)+p[i-1]*p[k]*p[j]; if(t&lt;u)&#123; u=t; s[i][j]=k;&#125; &#125; m[i][j]=u; return u;&#125; 一般来讲，当一个问题的所有子问题都至少要解一次时，用动态规划算法比用备忘录方法好。此时，动态规划算法没有任何多余的计算。同时，对于许多问题，常可利用其规则的表格存取方式，减少动态规划算法的计算时间和空间需求。当子问题空间中的部分子问题可不必求解时，用备忘录方法则较有利，因为从其控制结构可以看出，该方法只解那些确实需要求解的子问题。 3.3 最长公共子序列一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=｛x1,x2,…，xm｝，则另一序列Z=｛z1,z2,…，zk｝，X的子序列是指存在一个严格递增的下表序列｛i1，i2，…，ik｝使得对于所有j=1，2，…，k有zj=x(ij)。例如，序列Z=｛B,C,D,B｝是序列X=｛A,B,C,B,D,A,B｝的子序列，相应的递增下标序列为｛2，3，5，7｝。 给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。 最长公共子序列问题：给定两个序列X和Y，找出X和Y的最长公共子序列。 1. 最长公共子序列的结构 穷举搜索法是最容易想到的算法。对X的所有子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列。而且在检查过程中记录最长的公共子序列，X的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的每个子序列相应于下标集｛1，2，…，m｝的一个子集。因此，共有2^m个不同子序列，从而穷举搜索法需要指数时间。 事实上，最长公共子序列问题具有最优子结构性质。 设序列X=｛x1，x2，…，xm｝和Y=｛y1，y2，…，yn｝的最长公共子序列为Z=｛z1，z2，…，zk｝，则 （1）若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列； （2）若xm≠yn且zk≠xm，则Z是Xm-1和Y的最长公共子序列； （3）若xm≠yn且zk≠yn，则Z是X和Yn-1的最长公共子序列。 其中，Xm-1=｛x1，x2，…，xm-1｝；Yn-1=｛y1，y2，…，yn-1｝；Zk-1=｛z1，z2，…，zk-1｝。 由此可见，两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。 2. 子问题的递归结构 由最长公共子序列问题的最优子结构性质可知，要找出X和Y的最长公共子序列，可按以下方式递归计算： 当xm=yn时，找出Xm-1和Yn-1的最长公共子序列，然后在其尾部加上xm（=yn）即可得X和Y的最长公共子序列。 当xm≠yn时，必须解两个子问题，即找出Xm-1和Y的最长公共子序列及X和Yn-1的一个最长公共子序列。这两个公共子序列较长者即为X和Y的最长公共子序列。 由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如在计算X和Y的最长公共子序列时，可能要计算X和Yn-1及Xm-1和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，即计算Xm-1和Yn-1的最长公共子序列。 首先建立子问题最优值的递归关系。用c[i][j]记录序列Xi和Yj的最大公共子序列的长度。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列，故此时c[i][j]=0.在其他情况下，由最优子结构性质可建立递归关系如下： 123c[i][j] = 0 i=0,j=0 c[i-1][j-1]+1 i,j&gt;0;xi=yj max&#123;c[i][j-1],c[i-1][j]&#125; i,j&gt;0;xi≠yj 3. 计算最优值 直接利用递归式容易写出计算c[i][j]的递归算法，但其计算时间是随输入长度指数增长的。由于在所考虑的子问题空间中，总共有θ(mn)个不同的子问题，因此，用动态规划算法自底向上地计算最优值能提高算法的效率。 计算最长公共子序列长度的动态规划算法lcsLength以X和Y作为输入。输出两个数组c和b。其中c[i][j]存储Xi和Yj的最长公共子序列的长度，b[i][j]记录c[i][j]的值是由哪一个子问题的解得到的，这在构造最长公共子序列时要用到。问题的最优值，即X和Y的最长公共子序列的长度记录于c[m][n]中。 123456789101112131415161718192021222324public static int lcsLength(char []x, char[]y, int [][]b)&#123; int m=x.length-1; int n=y.length-1; int [][]c=new int [m+1][n+1]; for(int i=1;i&lt;=m;i++)c[i][0]=0; for(int i=1;i&lt;=n;i++)c[0][i]=0; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++)&#123; if(x[i]==y[j])&#123; c[i][j]=c[i-1][j-1]+1; b[i][j]=1; &#125; else if(c[i-1][j]&gt;=c[i][j-1])&#123; c[i][j]=c[i-1][j]; b[i][j]=2; &#125; else&#123; c[i][j]=c[i][j-1]; b[i][j]=3; &#125; &#125; return c[m][n];&#125; 由于每个数组单元的计算耗费O（1）时间，算法lcsLength耗时O(mn)。 4. 构造最长公共子序列 由算法lcsLength计算得到的数组b可用于快速构造序列X和Y的最长公共子序列。首先从b[m][n]开始，依其值在数组b中搜索。当b[i][j]=1时，表示Xi和Yj的最长公共子序列是由Xi-1和Yj-1的最长公共子序列在尾部加上xi所得到的子序列；当b[i][j]=2时，表示Xi和Yj的最长公共子序列与Xi-1和Yj的最长公共子序列相同；当b[i][j]=3时，表示Xi和Yj的最长公共子序列与Xi和Yj-1的最长公共子序列相同。 12345678910public static void lcs(int i, int j, char []x, int [][]b)&#123; if(i==0||j==0)return; if(b[i][j]==1)&#123; lcs(i-1,j-1,x,b); System.out.print(x[i]); &#125; else if(b[i][j]==2)lcs(i-1,j,x,b); else lcs(i,j-1,x,b);&#125; 算法lcs中，每一次递归调用使i或j减1，因此算法的计算时间为O（m+n）。 5. 算法的改进 只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。事实上，在计算c[i][j]时，只用到数组c的第i行和第i-1行。因此，用两行的数组空间就可以计算出最长公共子序列的长度。进一步的分析还可以将空间需求减至O(min｛m,n｝)。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"ZeromaXHe"},{"title":"【笔记】《算法设计与分析（第三版）》王晓东著 第二章  递归和分治策略","slug":"【笔记】《算法设计与分析（第三版）》王晓东著-第二章-递归和分治策略","date":"2019-04-05T11:04:00.000Z","updated":"2019-04-06T03:03:55.104Z","comments":true,"path":"2019/04/05/【笔记】《算法设计与分析（第三版）》王晓东著-第二章-递归和分治策略/","link":"","permalink":"http://yoursite.com/2019/04/05/【笔记】《算法设计与分析（第三版）》王晓东著-第二章-递归和分治策略/","excerpt":"","text":"第二章 递归与分治策略2.1 递归的概念Ackerman函数并非一切递归函数都能用非递归方式定义。为了对递归函数的复杂性有更多的了解，介绍一个双递归函数——Ackerman函数。 当一个函数以及它的一个变量是由函数自身定义时，称这个函数是双递归函数。 Ackerman函数A(n,m)有两个独立的整变量m&gt;=0和n&gt;=0，其定义如下：1234A(1,0)=2A(0,m)=1 m&gt;=0A(n,0)=n+2 n&gt;=2A(n,m)=A(A(n-1,m),m-1) n,m&gt;=1 A(n,4)的增长速度非常快，以至于没有适当的数学式子来表示这一函数。 单变量的Ackerman函数A(n)定义为：A(n)=A(n,n)。其拟逆函数a(n)在算法复杂性分析中常遇到。它定义为：a(n)=min{k|A(k)&gt;=n}。即a(n)是使n&lt;=A(k)成立的最小的k值。a(n)的增长速度非常慢，但理论上a(n)没有上界，它以难以想象的速度趋向无穷大。 整数划分问题将正整数n表示成一系列正整数的和：n=n1+n2+……+nk,其中n1&gt;=n2&gt;=……&gt;=nk&gt;=1,k&gt;=1。 正整数n的这种表示称为正整数n的划分。正整数n的不同划分个数称为正整数n的划分数，记作p(n)。 例如，正整数6有如下11种不同的划分，所以 p(6)=11。1234566；5+1；4+2，4+1+1；3+3，3+2+1，3+1+1+1；2+2+2，2+2+1+1，2+1+1+1+1；1+1+1+1+1+1。 在正整数n的所有不同的划分中，将最大加数n1不大于m的划分个数记作q(n,m)。可以建立q(n,m)的如下递归关系。 (1) q(n,1)=1,n&gt;=1 当最大加数n1不大于1时，任何正整数n只有一种划分形式，即n是n个1相加。 (2) q(n,m)=q(n,n),m&gt;=n 最大加数n1实际上不能大于n。因此，q(1,m)=1 (3) q(n,n)=1+q(n,n-1) 正整数n的划分由n1=n的划分和n1&lt;=n-1的划分组成。 (4) q(n,m)=q(n,m-1)+q(n-m,m),n&gt;m&gt;1 正整数n的最大加数n1不大于m的划分由n1=m的划分和n1&lt;=m-1的划分组成。 2.2 分治法的基本思想2.3 二分搜索技术2.4 大整数的乘法设X和Y都是n位的二进制整数，现在要计算它们的乘积XY。可以用小学所学的方法来设计计算乘积XY的算法，但这样做计算步骤太多，效率太低。如果将每2个1位数的乘法或加法看做一步运算，那么这种方法要进行O(n^2)步运算才能算出乘积XY。下面用分治法来设计更有效的大整数乘积算法。 将n位二进制整数X和Y都分为2段，每段的长为n/2位（为简单起见，假设n是2的幂），X=A(n/2位)B（n/2位）；Y=C(n/2位)D(n/2位) 由此，X=A*2^(n/2)+B,Y=C*2^(n/2)+D, X和Y的乘积为 XY = (A*2^(n/2)+B)(C*2^(n/2)+D) = AC*2^n + (AD + CB)*2^(n/2) + BD 如果按此式计算XY，则必须进行4次n/2位整数的乘法（AC,AD,BC,BD）,以及3次不超过2n位的整数加法（分别对应于式中的加号），此外还要进行2次移位（分别对应于式中的乘2^n和乘2^(n/2)）。所有这些加法和移位共用O(n)步运算。设T(n)是2个n位整数相乘所需的运算总数，则有12T(n)= O(1) n=1 4T(n/2)+O(n) n&gt;1 由此可得T(n)=O(n^2)。因此，直接用此式来计算X和Y的乘积并不比小学生的方法更有效。要想改进算法的计算复杂性，必须减少乘法次数。 下面把XY写成另一种形式 XY = AC*2^n + ((A-B)(D-C) + AC + BD）*2^(n/2) + BD 此式看起来似乎复杂些，但它仅需做3次n/2位整数的乘法（AC，BD和(A-B)(D-C)），6次加、减法和2次移位。由此可得12T(n) = O(1) n=1 3T(n/2)+O(n) n&gt;1 容易求得其解为T(n)=O(n^log3)=O(n^1.59)。这是一个较大的改进 2.5 Strassen矩阵乘法设A和B是2个n*n矩阵，它们的乘积AB同样是一个n*n矩阵。A和B的乘积矩阵C中元素C[i][j]定义为C[i][j]=∑A[i][k]B[k][j]。 若依次定义来计算A和B的乘积矩阵C，则每计算C的一个元素C[i][j]，需要做n次乘法运算和n-1次加法计算。因此，算出矩阵C的n^2个元素所需的计算时间为O(n^3)。 20世纪60年代末期，Strassen采用了类似于在大整数乘法中用过的分治技术，将计算2个n阶矩阵乘积所需的计算时间改进到O(n^log7)=O(n^2.81),其基本思想还是分治法。 首先，仍假设n是2的幂。将矩阵A, B和C中每一矩阵都分块成4个大小相等的矩阵，每个矩阵都是(n/2)*(n/2)的方阵。由此可将方程C=AB重写为12[C11 C12 = [A11 A12 [B11 B12 C21 C22] A21 A22] B21 B22] 由此可得1234C11 = A11 B11 + A12 B21C12 = A11 B12 + A12 B22C21 = A21 B11 + A22 B21C22 = A21 B12 + A22 B22 如果n=2，则2个2阶方阵的乘积可以直接计算出来，共需8次乘法和4次加法。当子矩阵的阶大于2时，为求2个子矩阵的积，可以继续将子矩阵分块，直到子矩阵的阶降为2.由此产生分治降阶的递归算法。以此算法，计算2个n阶方程的乘积和4个n/2阶方阵的加法。2个(n/2)*(n/2)矩阵的加法显然可以在O(n^2)时间内完成。因此，上述分治法的计算时间耗费T(n)应满足12T(n) = O(1) n=2 8T(n/2)+O(n^2) n&gt;2 这个递归方程的解仍然是T(n)=O(n^3).因此，该方法并不比用原始定义直接计算更有效。究其原因，乃是由于该方法没有减少矩阵的乘法次数。 Strassen提出了一种新算法来计算2个2阶方阵的乘积。他的算法只用了7次乘法运算，但增加了加、减法的运算次数。这7次乘法运算是1234567M1 = A11 (B12 - B22)M2 = (A11 + A12) B22M3 = (A21 + A22) B11M4 = A22 (B21 - B11)M5 = (A11 + A22)(B11 + B22)M6 = (A12 - A22)(B21 + B22)M7 = (A11 - A21)(B11 + B12) 做了这7次乘法运算后，再做若干次加、减法运算就可以得到1234C11 = M5 + M4 - M2 + M6C12 = M1 + M2C21 = M3 + M4C22 = M5 + M1 - M3 - M7 以上计算的正确性很容易验证。Strassen矩阵乘法中，用了7次对于n/2阶矩阵乘的递归调用和18次n/2阶矩阵的加减运算。由此可知，该算法所需的计算时间T(n)满足如下的递归方程12T(n) = O(1) n=2 7T(n/2)+O(n^2) n&gt;2 解此递归方程得T(n)=O(n^log7)=O(n^2.81).由此可见，Strassen矩阵乘法的计算时间复杂性比普通矩阵乘法有较大改进。 2.6 棋盘覆盖在一个2^k*2^k个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。显然特俗方格在棋盘上出现的位置有4^k种情形。 在棋盘覆盖问题中，要用每张可以覆盖3格的L型骨牌覆盖给定的特殊棋盘上除特俗方格以外的所有方格，且任何两个L型骨牌不得重叠覆盖。 用分治策略，可以设计出解棋盘覆盖问题的简洁算法。当k&gt;0时，将2^k*2^k棋盘分割为四个2^(k-1)*2^(k-1)子棋盘。为了将这三个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处。这3个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用过这种分割，直至棋盘简化为1*1棋盘。 设T(k)是算法chessBoard覆盖一个2^k*2^k棋盘所需的时间。从算法的分割策略可知，T(k)满足如下递归方程12T(k) = O(1) k=0 4T(k-1)+O(1) k&gt;0 解此递归方程可得T(k)=O(4^k).由于覆盖2^k*2^k棋盘所需的L型骨牌个数为(4^k-1)/3，故算法chessBoard是一个在渐进意义下最优的算法。 2.7 合并排序合并排序算法递归的描述：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。 改进：消去递归的合并排序算法。可以将数组a中国相邻元素两两配对。用合并算法将它们排序，构成n/2组长度为2的排好序的子数组段，然后再将它们排序成长度为4的排好序的子数组段，如此继续下去，直至整个数组排好序。 自然合并排序是上述合并排序算法mergeSort的变形。在上述合并排序算法中，第一步合并相邻长度为1的子数组段，这是因为长度为1的子数组段是已排好序的。事实上，对于初始给定的数组a，通常存在多个长度大于1的已自然排好序的子数组段。例如，若数组a中元素为｛4，8，3，7，1，5，6，2｝，则自然排好序的子数组段有｛4，8｝，｛3，7｝，｛1，5，6｝和｛2｝。用1次对数组a的线性扫描就足以找出所有这些排好序的子数组段。然后将相邻的排好序的子数组段两两合并，构成更大的排好序的子数组段。对上面的例子，经一次合并得到两个合并后的子数组段｛3，4，7，8｝和｛1，2，5，6｝。继续合并相邻排好序的子数组段，直至整个数组排好序。上面这两个数组段再合并后就得到｛1，2，3，4，5，6，7，8｝ 2.8 快速排序快速排序基本思想是，对于输入的子数组a[p:r],按以下3个步骤进行排序。 (1)分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r],使得a[p:q-1]中任何元素小于等于a[q],a[q+1:r]中任何元素大于等于a[q]。下标q在划分过程中确定。 (2)递归分解：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序。 (3)合并：由于a[p:q-1]和a[q+1:r]的排序是就地进行的，所以在a[p:q-1]和a[q+1:r]都已经排好序后不需要执行任何计算，a[p:r]就已排好序。 快速排序算法在平均情况下时间复杂性也是O(nlogn)，这在基于比较的排序算法类中算是快速的了，快速排序也因此而得名。 快速排序算法的性能取决于划分的对称性。通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。 2.9 线性时间选择本节讨论与排序问题类似的元素选择问题。元素选择问题的一般提法是：给定线性序集中n个元素和一个整数k，1&lt;=k&lt;=n，要求找出这n个元素中第k小的元素，即如果将这n个元素依其线性序排列时，排在第k个的元素即要找的元素。当k=1时，即要找最小元素；k=n时，即要找最大元素；当k=(n+1)/2时，称为找中位数。 在某些特殊情况下，很容易设计出解选择问题的线性时间算法。例如，找n个元素的最小元素和最大元素显然可以在O(n)时间完成。如果k&lt;=n/logn，通过堆排序算法可以在O(n+klogn)=O(n)时间内找出第k小的元素。当k&gt;=n-n/logn时也一样。 一般的选择问题，特别是中位数的选择问题似乎比找最小元素要难，但事实上，从渐进阶的意义上看，它们是一样的。一般的选择问题也可以在O(n)时间内得到解决。下面要讨论解一般的选择问题的分治算法randomizedSelect。该算法实际上是模仿快速排序算法设计出来的。其基本思想也是对输入数组进行递归划分。与快速排序算法不同的是，它只对划分出的子数组之一进行递归处理。 1234567private static Comparable randomizedSelect(int p, int r, int k)&#123; if(p==r) return a[p]; int i=randomizedPartition(p,r),j=i-p+1; if(k&lt;=j) return randomizedSelect(p,i,k); else return randomizedSelect(i+1,r,k-j);&#125; 可以看出，在最坏情况下，算法randomizedSelect需要Ω(n^2)计算时间。例如在找最小元素时，总是在最大元素处划分。尽管如此，该算法的平均性能很好。 下面来讨论类似于算法randomizedSelect但可以在最坏情况下用O(n)时间就完成选择任务的算法select。如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的两个子数组的长度都至少为原数组长度的ε倍（0&lt;ε&lt;1是某个正常数），那么就可以在最坏情况下用O(n)时间完成选择任务。例如ε=9/10，算法递归调用所产生的子数组的长度至少缩短1/10。所以在最坏情况下，算法所需的计算时间T(n)满足递归式T(n)&lt;=T(9n/10)+O(n).由此可得T(n)=O(n). 按以下步骤可以找到满足要求的划分基准： （1）将n个输入元素划分成[n/5](向上取整)个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共[n/5](向上取整)个。 （2）递归调用算法select来找出这[n/5](向上取整)个元素的中位数。如果[n/5](向上取整)是偶数，就找它的两个中位数中较大的一个。以这个元素作为划分基准。 2.10 最接近点对问题最接近点对问题的提法是：给定平面上n个点，找其中一对点，使得在n个点组成的所有点对中，该点对间的距离最小。 一维情形：显然可以先将n个点排序，然后一次线性扫描就可以找出最接近点对。耗时O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对一维的简单情形，还是尝试用分治法来求解，并希望推广到二维的情形。 1234567891011121314public static double cpair1(S)&#123; n=|S|; if (n&lt;2) return inf; m=S中各点坐标的中位数; 构造S1和S2; //S1=&#123;x∈S|s&lt;=m&#125;,S2=&#123;x∈S|x&gt;m&#125; d1=cpair1(S1); d2=cpair2(S2); p=max(S1); q=min(S2); d=min(d1,d2,q-p); return d;&#125; 由以上分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程 12T(n) = O(1) n&lt;4 2T(n/2)+O(n) n&gt;=4 解此递归方程可得T(n)=O(nlogn)。 这个算法看上去比用排序加扫描的算法复杂，然而它可以推广到二维的情形。 12345678910111213141516171819public static double cpair2(S)&#123; n=|S|; if(n&lt;2) return inf; 1. m=S中各点x间坐标的中位数； 构造S1和S2； //S1=&#123;p∈S|x(p)&lt;=m&#125;,S2=&#123;p∈S|x(p)&gt;m&#125; 2. d1=cpair2(S1); d2=cpair2(S2); 3. dm=min(d1,d2); 4. 设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合; P2是S2中距垂直分割线l的距离在dm之内的所有点组成的集合; 将P1和P2中的点依其y坐标排序； 并设X和Y是相应的已排好序的点列； 5. 通过扫描X以及对于X中每个店检查Y中与其距离在dm之内的所有点（最多6个）可以完成合并； 当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2dm的区间内移动； 6. d=min(dm,dl); return d;&#125; 下面分析算法cpair2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间。第3步和第6步用了常数时间。第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合要求，因此要做技术处理。采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列P*。在执行分治法的第4步时，只要对P*做一次线性扫描，即可抽取出所需要的排好序的点列X和Y。然后，在第5步中再对X做一次线性扫描，即可求得dl。因此，第4步和第5步的两遍扫描合在一起只要O(n)时间。由此可知，经过预排序处理后的算法cpair2所需的计算时间T(n)满足递归方程12T(n) = O(1) n&lt;4 2T(n/2)+O(n) n&gt;=4 由此易知，T(n)=O(nlogn)。预排序所需的计算时间显然为O(nlogn).因此，整个算法所需的计算时间为O(nlogn)。在渐进的意义下，此算法已是最优的了。 2.11 循环赛日程表","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"分治法","slug":"分治法","permalink":"http://yoursite.com/tags/分治法/"}],"author":"ZeromaXHe"},{"title":"【转】Markdown内LaTeX的用法","slug":"【转】Markdown内LaTeX的用法","date":"2019-04-04T09:03:00.000Z","updated":"2019-04-04T09:37:54.809Z","comments":true,"path":"2019/04/04/【转】Markdown内LaTeX的用法/","link":"","permalink":"http://yoursite.com/2019/04/04/【转】Markdown内LaTeX的用法/","excerpt":"","text":"试一试看看Hexo内部的markdown可不可以用LaTeX，怀疑默认的是不行的 转自： 作者：Henry606 来源：CSDN 原文：https://blog.csdn.net/HaleyPKU/article/details/80341932 Markdown中Latex常用语法常用希腊字母表 Name Display Capital Case Display Var Case Display \\alpha $\\alpha$ \\beta $\\beta$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\theta $\\theta$ \\Theta $\\Theta$ \\vartheta $\\vartheta$ \\mu $\\mu$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ \\varepsilon $\\varepsilon$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\varsigma $\\varsigma$ \\pi $\\pi$ \\Pi $\\Pi$ \\varpi $\\varpi$ \\omega $\\omega$ \\Omega $\\Omega$ \\xi $\\xi$ \\Xi $\\Xi$ \\zeta $\\zeta$ \\chi $\\chi$ \\rho $\\rho$ \\varrho $\\varrho$ \\phi $\\phi$ \\Phi $\\Phi$ \\varphi $\\varphi$ \\eta $\\eta$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\kappa $\\kappa$ \\nu $\\nu$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\psi $\\psi$ \\Psi $\\Psi$ \\tau $\\tau$ \\iota $\\iota$ o $o$ 常用特殊字符表 Name Display Name Display Name Display Name Display \\times $\\times$ \\div $\\div$ \\pm $\\pm$ \\mp $\\mp$ \\otimes $\\otimes$ \\ominus $\\ominus$ \\oplus $\\oplus$ \\odot $\\odot$ \\oslash $\\oslash$ \\triangleq $\\triangleq$ \\ne $\\ne$ \\equiv $\\equiv$ \\lt $\\lt$ \\gt $\\gt$ \\le $\\le$ \\ge $\\ge$ \\cup $\\cup$ \\cap $\\cap$ \\Cup $\\Cup$ \\Cap $\\Cap$ \\bigcup $\\bigcup$ \\bigcap $\\bigcap$ \\ast $\\ast$ \\star $\\star$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\circ $\\circ$ \\bullet $\\bullet$ \\bigcirc $\\bigcirc$ \\amalg $\\amalg$ \\to $\\to$ \\infty $\\infty$ \\vee $\\vee$ \\wedge $\\wedge$ \\lhd $\\lhd$ \\rhd $\\rhd$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\unlhd $\\unlhd$ \\unrhd $\\unrhd$ \\sqcap $\\sqcap$ \\sqcup $\\sqcup$ \\prec $\\prec$ \\succ $\\succ$ \\subset $\\subset$ \\supset $\\supset$ \\sim $\\sim$ \\approx $\\approx$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\cong $\\cong$ \\doteq $\\doteq$ \\setminus $\\setminus$ \\mid $\\mid$ \\ll $\\ll$ \\gg $\\gg$ \\parallel $\\parallel$ \\Join $\\Join$ \\in $\\in$ \\notin $\\notin$ \\propto $\\propto$ \\neg $\\neg$ \\ldots $\\ldots$ \\cdots $\\cdots$ \\forall $\\forall$ \\exists $\\exists$ \\vdots $\\vdots$ \\ddots $\\ddots$ \\aleph $\\aleph$ \\nabla $\\nabla$ \\imath $\\imath$ \\jmath $\\jmath$ \\ell $\\ell$ \\partial $\\partial$ \\int $\\int$ \\oint $\\oint$ \\uplus $\\uplus$ \\biguplus $\\biguplus$ 其他 Name Display Name Display \\triangleleft $\\triangleleft$ \\triangleright $\\triangleright$ \\bigtriangleup $\\bigtriangleup$ \\bigtriangledown $\\bigtriangledown$ \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\leftarrow $\\leftarrow$ \\rightarrow $\\rightarrow$ \\Leftarrow $\\Leftarrow$ \\Rightarrow $\\Rightarrow$ \\longleftarrow $\\longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longleftarrow $\\Longleftarrow$ \\Longrightarrow $\\Longrightarrow$ \\leftrightarrow $\\leftrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ \\leftharpoonup $\\leftharpoonup$ \\rightharpoonup $\\rightharpoonup$ \\leftharpoondown $\\leftharpoondown$ \\rightharpoondown $\\rightharpoondown$ \\rightleftharpoons $\\rightleftharpoons$ \\S $\\S$ \\nwarrow $\\nwarrow$ \\nearrow $\\nearrow$ \\swarrow $\\swarrow$ \\searrow $\\searrow$ \\triangle $\\triangle$ \\box $\\Box$ \\diamond $\\diamond$ \\diamondsuit $\\diamondsuit$ \\heartsuit $\\heartsuit$ \\clubsuit $\\clubsuit$ \\spadesuit $\\spadesuit$ 公式语法 上下标_ ^ , _{}^{}： $$ y = x_i^{a_1^2} $$ 公式中插入文本\\mbox{}： $$ y = x^2 \\; \\mbox{(二次函数)} $$ 公式中插入空格\\, \\; \\quad \\qquad间隔依次变宽： $$ ab $$ $$ a\\,b $$ $$ a\\;b $$ $$ a\\quad b $$ $$ a\\qquad b $$ 字母上方横线\\overline{}, \\bar{}： $$ \\overline{xyz} \\mbox{ 或 } \\bar{x} $$ 字母下方横线\\underline{}： $$ \\underline{ABC} $$ 字母上方波浪线\\tilde{}, \\widetilde{}： $$ \\tilde{A} \\mbox{ 或 } \\widetilde{ABC} $$ 字母上方尖号^\\hat{}, \\widehat{}： $$ \\hat{A} \\mbox{ 或 } \\widehat{ABC} $$ 字母上方箭头\\vec{}, \\overleftarrow{}, \\overrightarrow{}： $$ \\vec{ab} \\mbox{ 或 } \\overleftarrow{ab} \\mbox{ 或 } \\overrightarrow{ab} $$ 字母上方花括号\\overbrace{}，或下方花括号\\underbrace{}： $$ \\overbrace{1+2+3} \\mbox{ 或 } \\underbrace{1+2+3} $$ 字母上方点号\\dot{}, \\ddot{}： $$ \\dot{a} \\mbox{ 或 } \\ddot{a} $$ 省略号\\dots, \\cdots $$ 1,2,\\dots \\qquad 1,2,\\cdots $$ 积分\\int_{}^{}： $$ \\int_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x $$ 双重积分\\iint：$$ \\iint_{-\\infty}^{+\\infty} f(x,y) \\mathrm{d}x \\mathrm{d}y $$ 行内积分：$\\int_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x$ 行内积分limits模式\\int\\limits_{}^{}：$\\int\\limits_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x$ 行内积分display模式\\displaystyle \\int_{}^{}：$\\displaystyle \\int_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x$ 圆圈积分\\oint：$$ \\oint_{-\\infty}^{+\\infty} $$ 求和\\sum_{}^{}： $$ \\sum_{i=1}^{n} i^2 $$ 行内求和：$\\sum_{i=1}^{n} i^2$ 行内求和limits模式\\sum\\limits_{}^{}：$\\sum\\limits_{i=1}^{n} i^2$ 行内求和display模式\\displaystyle \\sum_{}^{}：$\\displaystyle \\sum_{i=1}^{n} i^2$ 求乘积\\prod_{}^{}： $$ \\prod_{i=1}^{n} a_i $$ 分数\\frac{up}{down}： $$ x_1,x_2 = \\frac{b^2 \\pm 4ac}{2a} $$ 根号\\sqrt： $$ r = \\sqrt{x^2+y^2} $$ 多次根号\\sqrt[n]： $$ x^{2/3} = \\sqrt[3]{x^2} $$ 编号 插入编号： 使用\\tag指令指定公式的具体编号，并使用\\label指令埋下锚点。如y=x^2 \\tag{1.5a} \\label{eq:test}： $$ y=x^2 \\tag{1.5a}\\label{eq:test} $$ 引用编号： 使用\\eqref指令引用前面埋下的锚点，\\eqref{eq:test}将显示为： $$ \\eqref{eq:test} $$ 方程组 左侧花括号 12345678910111213\\begin&#123;equation&#125;% \\begin&#123;equation*&#125; 加&apos;*&apos;去掉公式编号\\left\\&#123;\\begin&#123;aligned&#125; %请使用&apos;aligned&apos;或&apos;align*&apos;2x + y &amp;= 1 \\\\ %加&apos;&amp;&apos;指定对齐位置2x + 2y &amp;= 2\\end&#123;aligned&#125;\\right.\\end&#123;equation&#125;% \\end&#123;equation*&#125; 加&apos;*&apos;去掉公式编号% 注意：在 markdown 环境下，某些特殊字符，如&apos;\\&apos;, &apos;*&apos;等，会首先被 markdown 语法转义，然后再被 Latex 转义。% 因此有时候 &apos;\\&#123;&apos;需要写作&apos;\\\\&#123;&apos;，&apos;*&apos;需要写作&apos;\\*&apos;，&apos;\\\\&apos;需要写作&apos;\\\\\\\\&apos;等，视不同的解释环境而定 $$ \\begin{equation} \\left\\{ \\begin{aligned} 2x + y &amp;= 1 \\\\ 2x + 2y &amp;= 2 \\end{aligned} \\right. \\end{equation} $$ 注：如果各个方程需要在某个字符处对齐（如等号对齐），只需在所有要对齐的字符前加上 &amp; 符号。如果不需要公式编号，只需在宏包名称后加上 * 号。 分情况讨论方程式 12345f(x) =\\begin&#123;cases&#125;x^2 \\qquad &amp; a \\gt 0 \\\\e^x \\qquad &amp; a \\le 0\\end&#123;cases&#125; $$ f(x) = \\begin{cases} x^2 \\qquad &amp; a \\gt 0 \\\\ e^x \\qquad &amp; a \\le 0 \\end{cases} $$ $$ \\begin{aligned} a &amp;= 1 \\\\ bcd &amp;= 2 \\end{aligned} $$ 作者：Henry606来源：CSDN原文：https://blog.csdn.net/HaleyPKU/article/details/80341932版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/tags/杂项/"},{"name":"latex","slug":"latex","permalink":"http://yoursite.com/tags/latex/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"author":"ZeromaXHe"},{"title":"【力扣算法】2.两数相加","slug":"【力扣算法】2-两数相加","date":"2019-04-04T08:29:00.000Z","updated":"2019-04-04T08:47:22.984Z","comments":true,"path":"2019/04/04/【力扣算法】2-两数相加/","link":"","permalink":"http://yoursite.com/2019/04/04/【力扣算法】2-两数相加/","excerpt":"","text":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题解具体不想复制了，这道题不难，就是特殊情况可以看看： 测试用例 说明 l1=[0,1] l2=[0,1,2] 当一个列表比另一个列表长时。 l1=[] l2=[0,1] 当一个列表为空时，即出现空列表。 l1=[9,9] l2=[1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘 具体解答我在感想里面写，顺便写些注释。 感想具体解决答案：12345678910111213141516171819202122232425262728/** * 单链表的定义： * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125;//构造函数 * &#125; */ public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0);//之所以叫dummyHead就是因为链表的头是val为0的哑节点 ListNode p = l1, q = l2, curr = dummyHead;//p是指示l1上第几位的指针，q是l2的，curr是最后返回的链表的 int carry = 0; //while内部之所以是||，就是为了走完全程，怕上面特例的第三种 while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0;//加判断就是避免前面或的情况导致进入循环内部的空节点 int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry);//处理最后多出来的进位 &#125; return dummyHead.next;//注意返回的是next&#125; 请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 借这道题熟悉一下java的链表用法，但有趣的是题解内的拓展： 123如果链表中的数字不是按逆序存储的呢？例如：(3 → 4 → 2 ) + ( 4 → 6 → 5) = 8 → 0 → 7 如果按我的想法那就是重新头插法建两个新的链表然后按原题做，但不知道有没有更好的办法","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"linklist","slug":"linklist","permalink":"http://yoursite.com/tags/linklist/"}],"author":"ZeromaXHe"},{"title":"【力扣算法】1.两数之和","slug":"【力扣算法】1-两数之和","date":"2019-04-04T07:35:00.000Z","updated":"2019-04-04T08:13:00.091Z","comments":true,"path":"2019/04/04/【力扣算法】1-两数之和/","link":"","permalink":"http://yoursite.com/2019/04/04/【力扣算法】1-两数之和/","excerpt":"","text":"题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = \\[2, 7, 11, 15], target = 9因为 nums\\[0] + nums\\[1] = 2 + 7 = 9所以返回 \\[0, 1] 题解1. 暴力法暴力法很简单。遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 复杂度分析： 时间复杂度：O(n^2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)的时间。因此时间复杂度为 O(n^2)。 空间复杂度：O(1)。 2. 两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 复杂度分析： 时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 3. 一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 复杂度分析： 时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 做完的感悟（1） 对于暴力法的优化，首先想到的是建立一个数组，数组上限为target/2（奇数就是再加一），然后将0~target/2直接存，target/2以上的反向存，当发现数组里有数时就检验是否相等，不相等的话就可以输出了。 后来看了题解才发现，自己这样做其实就等同于自己在实现一个使用范围受限的hash map……直接套用java自带的HashMap就好了，时间复杂度还是O(1)……更不要说java实现的HashMap对冲突较多的节点用红黑树去优化还有自动扩容等特点了。 数据结构学了还是想不到要用，是真的伤……还是得多看多练啊 （2） 在HashMap中通过get()来获取value，通过put()来插入value，ContainsKey()则用来检验对象是否已经存在。 至于HashMap 在java8中的详细介绍，可以参考这篇文章《Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）》 摘些和本题目相关的部分吧： JDK1.8引入红黑树大程度优化了HashMap的性能，这主要体现在hash算法不均匀时，即产生的链表非常长，这时把链表转为红黑树可以将复杂度从O(n)降到O(logn)； Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 （3） 把Integer拼写成Interger的错误我都不想说了……【捂脸】","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"http://yoursite.com/tags/hashmap/"}],"author":"ZeromaXHe"},{"title":"【Java】数组的创建方法","slug":"【Java】数组的创建方法","date":"2019-04-04T06:40:00.000Z","updated":"2019-04-04T07:08:50.286Z","comments":true,"path":"2019/04/04/【Java】数组的创建方法/","link":"","permalink":"http://yoursite.com/2019/04/04/【Java】数组的创建方法/","excerpt":"","text":"1.一维数组1.1 一维数组的创建一维数组的创建有下列两种形式： 1.1.1 先声明，再用new运算符进行内存分配声明一位数组有下列两种方式：12数组元素类型 数组名字[];数组元素类型[] 数组名字; 声明数组后，还不能立即访问它的任何元素，因为声明数组只是给出了数组名字和元素的数据类型，想要真正使用数组，还要为它分配内存空间。在为数组分配内存空间时必须指明数组的长度。为数组分配内存空间的语法格式如下：1数组名字 = new 数组元素的类型[数组元素的个数]; 例： 12int arr[];arr=new int[5]; 1.1.2 声明的同时为数组分配内存语法如下：1数组元素的类型 数组名 = new 数组元素的类型[数组元素的个数]; 例如：1int month[] = new int[12]; 1.2 一维数组的初始化两种形式：12int arr[] = new int[]&#123;1,2,3,5,25&#125;; //第一种初始化方式int arr2[] = &#123;34,23,12,6&#125;; //第二种初始化方式 2. 二维数组2.1 二维数组的创建声明：1int myarr[][]; 分配内存空间： (1)直接为每一维数组分配内存空间1a = new int[2][4]; (2)分别为每一维分配内存123a = new int[2][];a[0] = new int[2];a[1] = new int[3]; 2.2 二维数组的初始化例：1int myarr[][] = &#123;&#123;12,0&#125;,&#123;45,10&#125;&#125;;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"author":"ZeromaXHe"},{"title":"Hello World","slug":"hello-world","date":"2019-04-03T05:05:15.003Z","updated":"2019-04-03T05:05:15.003Z","comments":true,"path":"2019/04/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}