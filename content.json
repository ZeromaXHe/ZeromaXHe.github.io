{"meta":{"title":"ZeromaXHe的博客","subtitle":"欢迎来到ZeromaXHe的博客！","description":"测试一下用GitHub做博客是什么感觉，哈哈哈","author":"ZeromaXHe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Test","date":"2019-04-04T07:14:57.000Z","updated":"2019-04-04T07:17:29.752Z","comments":true,"path":"Test/index.html","permalink":"http://yoursite.com/Test/index.html","excerpt":"","text":"Try to test what the so-called Pages mean. (Still don’t know where they are…)"}],"posts":[{"title":"【转】Markdown内LaTeX的用法","slug":"【转】Markdown内LaTeX的用法","date":"2019-04-04T09:03:00.000Z","updated":"2019-04-04T09:37:54.809Z","comments":true,"path":"2019/04/04/【转】Markdown内LaTeX的用法/","link":"","permalink":"http://yoursite.com/2019/04/04/【转】Markdown内LaTeX的用法/","excerpt":"","text":"试一试看看Hexo内部的markdown可不可以用LaTeX，怀疑默认的是不行的 转自： 作者：Henry606 来源：CSDN 原文：https://blog.csdn.net/HaleyPKU/article/details/80341932 Markdown中Latex常用语法常用希腊字母表 Name Display Capital Case Display Var Case Display \\alpha $\\alpha$ \\beta $\\beta$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\theta $\\theta$ \\Theta $\\Theta$ \\vartheta $\\vartheta$ \\mu $\\mu$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ \\varepsilon $\\varepsilon$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\varsigma $\\varsigma$ \\pi $\\pi$ \\Pi $\\Pi$ \\varpi $\\varpi$ \\omega $\\omega$ \\Omega $\\Omega$ \\xi $\\xi$ \\Xi $\\Xi$ \\zeta $\\zeta$ \\chi $\\chi$ \\rho $\\rho$ \\varrho $\\varrho$ \\phi $\\phi$ \\Phi $\\Phi$ \\varphi $\\varphi$ \\eta $\\eta$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\kappa $\\kappa$ \\nu $\\nu$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\psi $\\psi$ \\Psi $\\Psi$ \\tau $\\tau$ \\iota $\\iota$ o $o$ 常用特殊字符表 Name Display Name Display Name Display Name Display \\times $\\times$ \\div $\\div$ \\pm $\\pm$ \\mp $\\mp$ \\otimes $\\otimes$ \\ominus $\\ominus$ \\oplus $\\oplus$ \\odot $\\odot$ \\oslash $\\oslash$ \\triangleq $\\triangleq$ \\ne $\\ne$ \\equiv $\\equiv$ \\lt $\\lt$ \\gt $\\gt$ \\le $\\le$ \\ge $\\ge$ \\cup $\\cup$ \\cap $\\cap$ \\Cup $\\Cup$ \\Cap $\\Cap$ \\bigcup $\\bigcup$ \\bigcap $\\bigcap$ \\ast $\\ast$ \\star $\\star$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\circ $\\circ$ \\bullet $\\bullet$ \\bigcirc $\\bigcirc$ \\amalg $\\amalg$ \\to $\\to$ \\infty $\\infty$ \\vee $\\vee$ \\wedge $\\wedge$ \\lhd $\\lhd$ \\rhd $\\rhd$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\unlhd $\\unlhd$ \\unrhd $\\unrhd$ \\sqcap $\\sqcap$ \\sqcup $\\sqcup$ \\prec $\\prec$ \\succ $\\succ$ \\subset $\\subset$ \\supset $\\supset$ \\sim $\\sim$ \\approx $\\approx$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\cong $\\cong$ \\doteq $\\doteq$ \\setminus $\\setminus$ \\mid $\\mid$ \\ll $\\ll$ \\gg $\\gg$ \\parallel $\\parallel$ \\Join $\\Join$ \\in $\\in$ \\notin $\\notin$ \\propto $\\propto$ \\neg $\\neg$ \\ldots $\\ldots$ \\cdots $\\cdots$ \\forall $\\forall$ \\exists $\\exists$ \\vdots $\\vdots$ \\ddots $\\ddots$ \\aleph $\\aleph$ \\nabla $\\nabla$ \\imath $\\imath$ \\jmath $\\jmath$ \\ell $\\ell$ \\partial $\\partial$ \\int $\\int$ \\oint $\\oint$ \\uplus $\\uplus$ \\biguplus $\\biguplus$ 其他 Name Display Name Display \\triangleleft $\\triangleleft$ \\triangleright $\\triangleright$ \\bigtriangleup $\\bigtriangleup$ \\bigtriangledown $\\bigtriangledown$ \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\leftarrow $\\leftarrow$ \\rightarrow $\\rightarrow$ \\Leftarrow $\\Leftarrow$ \\Rightarrow $\\Rightarrow$ \\longleftarrow $\\longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longleftarrow $\\Longleftarrow$ \\Longrightarrow $\\Longrightarrow$ \\leftrightarrow $\\leftrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ \\leftharpoonup $\\leftharpoonup$ \\rightharpoonup $\\rightharpoonup$ \\leftharpoondown $\\leftharpoondown$ \\rightharpoondown $\\rightharpoondown$ \\rightleftharpoons $\\rightleftharpoons$ \\S $\\S$ \\nwarrow $\\nwarrow$ \\nearrow $\\nearrow$ \\swarrow $\\swarrow$ \\searrow $\\searrow$ \\triangle $\\triangle$ \\box $\\Box$ \\diamond $\\diamond$ \\diamondsuit $\\diamondsuit$ \\heartsuit $\\heartsuit$ \\clubsuit $\\clubsuit$ \\spadesuit $\\spadesuit$ 公式语法 上下标_ ^ , _{}^{}： $$ y = x_i^{a_1^2} $$ 公式中插入文本\\mbox{}： $$ y = x^2 \\; \\mbox{(二次函数)} $$ 公式中插入空格\\, \\; \\quad \\qquad间隔依次变宽： $$ ab $$ $$ a\\,b $$ $$ a\\;b $$ $$ a\\quad b $$ $$ a\\qquad b $$ 字母上方横线\\overline{}, \\bar{}： $$ \\overline{xyz} \\mbox{ 或 } \\bar{x} $$ 字母下方横线\\underline{}： $$ \\underline{ABC} $$ 字母上方波浪线\\tilde{}, \\widetilde{}： $$ \\tilde{A} \\mbox{ 或 } \\widetilde{ABC} $$ 字母上方尖号^\\hat{}, \\widehat{}： $$ \\hat{A} \\mbox{ 或 } \\widehat{ABC} $$ 字母上方箭头\\vec{}, \\overleftarrow{}, \\overrightarrow{}： $$ \\vec{ab} \\mbox{ 或 } \\overleftarrow{ab} \\mbox{ 或 } \\overrightarrow{ab} $$ 字母上方花括号\\overbrace{}，或下方花括号\\underbrace{}： $$ \\overbrace{1+2+3} \\mbox{ 或 } \\underbrace{1+2+3} $$ 字母上方点号\\dot{}, \\ddot{}： $$ \\dot{a} \\mbox{ 或 } \\ddot{a} $$ 省略号\\dots, \\cdots $$ 1,2,\\dots \\qquad 1,2,\\cdots $$ 积分\\int_{}^{}： $$ \\int_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x $$ 双重积分\\iint：$$ \\iint_{-\\infty}^{+\\infty} f(x,y) \\mathrm{d}x \\mathrm{d}y $$ 行内积分：$\\int_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x$ 行内积分limits模式\\int\\limits_{}^{}：$\\int\\limits_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x$ 行内积分display模式\\displaystyle \\int_{}^{}：$\\displaystyle \\int_{-\\infty}^{+\\infty} f(x) \\mathrm{d}x$ 圆圈积分\\oint：$$ \\oint_{-\\infty}^{+\\infty} $$ 求和\\sum_{}^{}： $$ \\sum_{i=1}^{n} i^2 $$ 行内求和：$\\sum_{i=1}^{n} i^2$ 行内求和limits模式\\sum\\limits_{}^{}：$\\sum\\limits_{i=1}^{n} i^2$ 行内求和display模式\\displaystyle \\sum_{}^{}：$\\displaystyle \\sum_{i=1}^{n} i^2$ 求乘积\\prod_{}^{}： $$ \\prod_{i=1}^{n} a_i $$ 分数\\frac{up}{down}： $$ x_1,x_2 = \\frac{b^2 \\pm 4ac}{2a} $$ 根号\\sqrt： $$ r = \\sqrt{x^2+y^2} $$ 多次根号\\sqrt[n]： $$ x^{2/3} = \\sqrt[3]{x^2} $$ 编号 插入编号： 使用\\tag指令指定公式的具体编号，并使用\\label指令埋下锚点。如y=x^2 \\tag{1.5a} \\label{eq:test}： $$ y=x^2 \\tag{1.5a}\\label{eq:test} $$ 引用编号： 使用\\eqref指令引用前面埋下的锚点，\\eqref{eq:test}将显示为： $$ \\eqref{eq:test} $$ 方程组 左侧花括号 12345678910111213\\begin&#123;equation&#125;% \\begin&#123;equation*&#125; 加&apos;*&apos;去掉公式编号\\left\\&#123;\\begin&#123;aligned&#125; %请使用&apos;aligned&apos;或&apos;align*&apos;2x + y &amp;= 1 \\\\ %加&apos;&amp;&apos;指定对齐位置2x + 2y &amp;= 2\\end&#123;aligned&#125;\\right.\\end&#123;equation&#125;% \\end&#123;equation*&#125; 加&apos;*&apos;去掉公式编号% 注意：在 markdown 环境下，某些特殊字符，如&apos;\\&apos;, &apos;*&apos;等，会首先被 markdown 语法转义，然后再被 Latex 转义。% 因此有时候 &apos;\\&#123;&apos;需要写作&apos;\\\\&#123;&apos;，&apos;*&apos;需要写作&apos;\\*&apos;，&apos;\\\\&apos;需要写作&apos;\\\\\\\\&apos;等，视不同的解释环境而定 $$ \\begin{equation} \\left\\{ \\begin{aligned} 2x + y &amp;= 1 \\\\ 2x + 2y &amp;= 2 \\end{aligned} \\right. \\end{equation} $$ 注：如果各个方程需要在某个字符处对齐（如等号对齐），只需在所有要对齐的字符前加上 &amp; 符号。如果不需要公式编号，只需在宏包名称后加上 * 号。 分情况讨论方程式 12345f(x) =\\begin&#123;cases&#125;x^2 \\qquad &amp; a \\gt 0 \\\\e^x \\qquad &amp; a \\le 0\\end&#123;cases&#125; $$ f(x) = \\begin{cases} x^2 \\qquad &amp; a \\gt 0 \\\\ e^x \\qquad &amp; a \\le 0 \\end{cases} $$ $$ \\begin{aligned} a &amp;= 1 \\\\ bcd &amp;= 2 \\end{aligned} $$ 作者：Henry606来源：CSDN原文：https://blog.csdn.net/HaleyPKU/article/details/80341932版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/categories/杂项/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/tags/杂项/"},{"name":"latex","slug":"latex","permalink":"http://yoursite.com/tags/latex/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"author":"ZeromaXHe"},{"title":"【力扣算法】2.两数相加","slug":"【力扣算法】2-两数相加","date":"2019-04-04T08:29:00.000Z","updated":"2019-04-04T08:47:22.984Z","comments":true,"path":"2019/04/04/【力扣算法】2-两数相加/","link":"","permalink":"http://yoursite.com/2019/04/04/【力扣算法】2-两数相加/","excerpt":"","text":"题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题解具体不想复制了，这道题不难，就是特殊情况可以看看： 测试用例 说明 l1=[0,1] l2=[0,1,2] 当一个列表比另一个列表长时。 l1=[] l2=[0,1] 当一个列表为空时，即出现空列表。 l1=[9,9] l2=[1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘 具体解答我在感想里面写，顺便写些注释。 感想具体解决答案：12345678910111213141516171819202122232425262728/** * 单链表的定义： * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125;//构造函数 * &#125; */ public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0);//之所以叫dummyHead就是因为链表的头是val为0的哑节点 ListNode p = l1, q = l2, curr = dummyHead;//p是指示l1上第几位的指针，q是l2的，curr是最后返回的链表的 int carry = 0; //while内部之所以是||，就是为了走完全程，怕上面特例的第三种 while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0;//加判断就是避免前面或的情况导致进入循环内部的空节点 int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry);//处理最后多出来的进位 &#125; return dummyHead.next;//注意返回的是next&#125; 请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 借这道题熟悉一下java的链表用法，但有趣的是题解内的拓展： 123如果链表中的数字不是按逆序存储的呢？例如：(3 → 4 → 2 ) + ( 4 → 6 → 5) = 8 → 0 → 7 如果按我的想法那就是重新头插法建两个新的链表然后按原题做，但不知道有没有更好的办法","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"linklist","slug":"linklist","permalink":"http://yoursite.com/tags/linklist/"}],"author":"ZeromaXHe"},{"title":"【力扣算法】1.两数之和","slug":"【力扣算法】1-两数之和","date":"2019-04-04T07:35:00.000Z","updated":"2019-04-04T08:13:00.091Z","comments":true,"path":"2019/04/04/【力扣算法】1-两数之和/","link":"","permalink":"http://yoursite.com/2019/04/04/【力扣算法】1-两数之和/","excerpt":"","text":"题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = \\[2, 7, 11, 15], target = 9因为 nums\\[0] + nums\\[1] = 2 + 7 = 9所以返回 \\[0, 1] 题解1. 暴力法暴力法很简单。遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 复杂度分析： 时间复杂度：O(n^2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)的时间。因此时间复杂度为 O(n^2)。 空间复杂度：O(1)。 2. 两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 复杂度分析： 时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。 3. 一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 复杂度分析： 时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。 做完的感悟（1） 对于暴力法的优化，首先想到的是建立一个数组，数组上限为target/2（奇数就是再加一），然后将0~target/2直接存，target/2以上的反向存，当发现数组里有数时就检验是否相等，不相等的话就可以输出了。 后来看了题解才发现，自己这样做其实就等同于自己在实现一个使用范围受限的hash map……直接套用java自带的HashMap就好了，时间复杂度还是O(1)……更不要说java实现的HashMap对冲突较多的节点用红黑树去优化还有自动扩容等特点了。 数据结构学了还是想不到要用，是真的伤……还是得多看多练啊 （2） 在HashMap中通过get()来获取value，通过put()来插入value，ContainsKey()则用来检验对象是否已经存在。 至于HashMap 在java8中的详细介绍，可以参考这篇文章《Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）》 摘些和本题目相关的部分吧： JDK1.8引入红黑树大程度优化了HashMap的性能，这主要体现在hash算法不均匀时，即产生的链表非常长，这时把链表转为红黑树可以将复杂度从O(n)降到O(logn)； Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 （3） 把Integer拼写成Interger的错误我都不想说了……【捂脸】","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"hashmap","slug":"hashmap","permalink":"http://yoursite.com/tags/hashmap/"}],"author":"ZeromaXHe"},{"title":"【Java】数组的创建方法","slug":"【Java】数组的创建方法","date":"2019-04-04T06:40:00.000Z","updated":"2019-04-04T07:08:50.286Z","comments":true,"path":"2019/04/04/【Java】数组的创建方法/","link":"","permalink":"http://yoursite.com/2019/04/04/【Java】数组的创建方法/","excerpt":"","text":"1.一维数组1.1 一维数组的创建一维数组的创建有下列两种形式： 1.1.1 先声明，再用new运算符进行内存分配声明一位数组有下列两种方式：12数组元素类型 数组名字[];数组元素类型[] 数组名字; 声明数组后，还不能立即访问它的任何元素，因为声明数组只是给出了数组名字和元素的数据类型，想要真正使用数组，还要为它分配内存空间。在为数组分配内存空间时必须指明数组的长度。为数组分配内存空间的语法格式如下：1数组名字 = new 数组元素的类型[数组元素的个数]; 例： 12int arr[];arr=new int[5]; 1.1.2 声明的同时为数组分配内存语法如下：1数组元素的类型 数组名 = new 数组元素的类型[数组元素的个数]; 例如：1int month[] = new int[12]; 1.2 一维数组的初始化两种形式：12int arr[] = new int[]&#123;1,2,3,5,25&#125;; //第一种初始化方式int arr2[] = &#123;34,23,12,6&#125;; //第二种初始化方式 2. 二维数组2.1 二维数组的创建声明：1int myarr[][]; 分配内存空间： (1)直接为每一维数组分配内存空间1a = new int[2][4]; (2)分别为每一维分配内存123a = new int[2][];a[0] = new int[2];a[1] = new int[3]; 2.2 二维数组的初始化例：1int myarr[][] = &#123;&#123;12,0&#125;,&#123;45,10&#125;&#125;;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"author":"ZeromaXHe"},{"title":"Hello World","slug":"hello-world","date":"2019-04-03T05:05:15.003Z","updated":"2019-04-03T05:05:15.003Z","comments":true,"path":"2019/04/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}